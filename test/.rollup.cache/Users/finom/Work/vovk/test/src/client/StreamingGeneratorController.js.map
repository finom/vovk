{"version":3,"file":"StreamingGeneratorController.js","sourceRoot":"","sources":["StreamingGeneratorController.ts"],"names":[],"mappings":"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","sourcesContent":["import { type VovkRequest, get, post, prefix } from 'vovk';\n\nexport type Token = { token: string; query: 'queryValue' };\n\n@prefix('streaming-generator')\nexport default class StreamingGeneratorController {\n  @get.auto()\n  static async *getWithStreaming(req: VovkRequest<null, { query: 'queryValue' }>) {\n    const query = req.nextUrl.searchParams.get('query');\n\n    const tokens: Token[] = [\n      { token: 'first', query },\n      { token: 'second', query },\n      { token: 'third', query },\n    ];\n\n    for (const token of tokens) {\n      yield token;\n    }\n  }\n\n  @post.auto()\n  static async *postWithAsyncStreaming(req: VovkRequest<Omit<Token, 'query'>[], { query: 'queryValue' }>) {\n    const body = await req.json();\n    const query = req.nextUrl.searchParams.get('query');\n\n    for (const token of body) {\n      await new Promise((resolve) => setTimeout(resolve, 200));\n      yield { ...token, query };\n    }\n  }\n\n  @post.auto()\n  static async *postWithStreaming(req: VovkRequest<Omit<Token, 'query'>[], { query: 'queryValue' }>) {\n    const body = await req.json();\n    const query = req.nextUrl.searchParams.get('query');\n\n    for (const token of body) {\n      yield { ...token, query };\n    }\n  }\n\n  @post.auto()\n  static async *postWithStreamingAndImmediateError(req: VovkRequest<Omit<Token, 'query'>[], { query: 'queryValue' }>) {\n    await new Promise((resolve) => setTimeout(resolve, 200));\n    if (req) {\n      throw new Error('Immediate error');\n    }\n\n    yield {} as Token;\n  }\n\n  @post.auto()\n  static async *postWithStreamingAndDelayedError(req: VovkRequest<Omit<Token, 'query'>[], { query: 'queryValue' }>) {\n    const body = await req.json();\n    const query = req.nextUrl.searchParams.get('query');\n\n    let count = 0;\n    for (const token of body) {\n      if (++count === 3) {\n        throw new Error('oh no');\n      }\n      await new Promise((resolve) => setTimeout(resolve, 200));\n      yield { ...token, query };\n    }\n  }\n\n  @post.auto()\n  static async *postWithStreamingAndDelayedCustomError(\n    req: VovkRequest<Omit<Token, 'query'>[], { query: 'queryValue' }>\n  ) {\n    const body = await req.json();\n    const query = req.nextUrl.searchParams.get('query');\n\n    let count = 0;\n    for (const token of body) {\n      if (++count === 3) {\n        throw { customError: 'custom error' };\n      }\n      await new Promise((resolve) => setTimeout(resolve, 200));\n      yield { ...token, query };\n    }\n  }\n\n  @post.auto()\n  static async *postWithStreamingAndDelayedUnhandledError(\n    req: VovkRequest<Omit<Token, 'query'>[], { query: 'queryValue' }>\n  ) {\n    const body = await req.json();\n    const query = req.nextUrl.searchParams.get('query');\n\n    let count = 0;\n    for (const token of body) {\n      if (++count === 3) {\n        throw new Error('Unhandled error');\n      }\n      await new Promise((resolve) => setTimeout(resolve, 200));\n      yield { ...token, query };\n    }\n  }\n}\n"]}