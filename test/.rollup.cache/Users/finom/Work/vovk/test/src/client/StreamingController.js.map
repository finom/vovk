{"version":3,"file":"StreamingController.js","sourceRoot":"","sources":["StreamingController.ts"],"names":[],"mappings":"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","sourcesContent":["import { headers } from 'next/headers';\nimport { type VovkRequest, post, prefix } from 'vovk';\nimport { JSONLinesResponse } from 'vovk';\n\nexport type Token = { token: string; query: 'queryValue' };\n\n@prefix('streaming')\nexport default class StreamingController {\n  @post.auto()\n  static async postWithStreaming(req: VovkRequest<Omit<Token, 'query'>[], { query: 'queryValue' }>) {\n    const body = await req.json();\n    const query = req.nextUrl.searchParams.get('query');\n\n    const response = new JSONLinesResponse<Token>(await headers());\n\n    void (async () => {\n      for (const token of body) {\n        await new Promise((resolve) => setTimeout(resolve, 200));\n        response.send({ ...token, query });\n      }\n\n      response.close();\n    })();\n\n    return response;\n  }\n\n  @post.auto()\n  static async postWithStreamingAndImmediateError(req: VovkRequest<Omit<Token, 'query'>[], { query: 'queryValue' }>) {\n    if (req) {\n      throw new Error('Immediate error');\n    }\n\n    const response = new JSONLinesResponse<Token>(await headers());\n\n    return response;\n  }\n\n  @post.auto()\n  static async postWithStreamingAndDelayedError(req: VovkRequest<Omit<Token, 'query'>[], { query: 'queryValue' }>) {\n    const body = await req.json();\n    const query = req.nextUrl.searchParams.get('query');\n\n    const response = new JSONLinesResponse<Token>(await headers());\n\n    let count = 0;\n    void (async () => {\n      for (const token of body) {\n        if (++count === 3) {\n          return response.throw('oh no');\n        }\n        await new Promise((resolve) => setTimeout(resolve, 200));\n        response.send({ ...token, query });\n      }\n    })();\n\n    return response;\n  }\n\n  @post.auto()\n  static async postWithStreamingAndDelayedCustomError(\n    req: VovkRequest<Omit<Token, 'query'>[], { query: 'queryValue' }>\n  ) {\n    const body = await req.json();\n    const query = req.nextUrl.searchParams.get('query');\n\n    const response = new JSONLinesResponse<Token>(await headers());\n\n    let count = 0;\n    void (async () => {\n      for (const token of body) {\n        if (++count === 3) {\n          return response.throw({ customError: 'custom error' });\n        }\n        await new Promise((resolve) => setTimeout(resolve, 200));\n        response.send({ ...token, query });\n      }\n    })();\n\n    return response;\n  }\n\n  @post.auto()\n  static async postWithStreamingAndDelayedUnhandledError(\n    req: VovkRequest<Omit<Token, 'query'>[], { query: 'queryValue' }>\n  ) {\n    const body = await req.json();\n    const query = req.nextUrl.searchParams.get('query');\n\n    const response = new JSONLinesResponse<Token>(await headers());\n\n    let count = 0;\n    void (async () => {\n      for (const token of body) {\n        if (++count === 3) {\n          throw new Error('Unhandled error');\n        }\n        await new Promise((resolve) => setTimeout(resolve, 200));\n        response.send({ ...token, query });\n      }\n    })();\n\n    return response;\n  }\n}\n"]}