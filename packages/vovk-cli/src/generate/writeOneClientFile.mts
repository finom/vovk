import fs from 'fs/promises';
import path from 'node:path';
import ejs from 'ejs';
import _ from 'lodash';
import {
  createCodeExamples,
  VovkReadmeConfig,
  VovkSchemaIdEnum,
  VovkSnippetsConfig,
  type VovkSchema,
  type VovkStrictConfig,
} from 'vovk';
import * as YAML from 'yaml';
import TOML from '@iarna/toml';
import type { PackageJson } from 'type-fest';
import prettify from '../utils/prettify.mjs';
import type { ProjectInfo } from '../getProjectInfo/index.mjs';
import type { ClientTemplateFile } from './getClientTemplateFiles.mjs';
import type { ClientImports } from './getTemplateClientImports.mjs';
import { ROOT_SEGMENT_FILE_NAME } from '../dev/writeOneSegmentSchemaFile.mjs';
import type { Segment } from '../locateSegments.mjs';
import { compileJSONSchemaToTypeScriptType } from '../utils/compileJSONSchemaToTypeScriptType.mjs';

export function normalizeOutTemplatePath(out: string, packageJson: PackageJson): string {
  return out.replace('[package_name]', packageJson.name?.replace(/-/g, '_') ?? 'my_package_name');
}

export default async function writeOneClientFile({
  cwd,
  projectInfo,
  clientTemplateFile,
  fullSchema,
  prettifyClient,
  segmentName,
  imports,
  templateContent,
  matterResult: { data, content },
  package: packageJson,
  readme,
  snippets,
  isEnsuringClient,
  outCwdRelativeDir,
  // templateDef,
  locatedSegments,
  isNodeNextResolution,
  hasMixins,
  isVovkProject,
  vovkCliPackage,
  isBundle,
  origin,
}: {
  cwd: string;
  projectInfo: ProjectInfo;
  clientTemplateFile: ClientTemplateFile;
  fullSchema: VovkSchema;
  prettifyClient: boolean;
  segmentName: string | null; // null for composed client
  imports: ClientImports;
  templateContent: string;
  matterResult: {
    data: {
      imports?: string[];
    };
    content: string;
  };
  package: PackageJson;
  readme: VovkReadmeConfig;
  snippets: VovkSnippetsConfig;
  isEnsuringClient: boolean;
  outCwdRelativeDir: string;
  templateDef: VovkStrictConfig['clientTemplateDefs'][string];
  locatedSegments: Segment[];
  isNodeNextResolution: boolean;
  hasMixins: boolean;
  isVovkProject: boolean;
  vovkCliPackage: PackageJson;
  isBundle: boolean;
  origin: string | null;
}) {
  const { config, apiRoot } = projectInfo;

  const { templateFilePath, relativeDir } = clientTemplateFile;
  const locatedSegmentsByName = _.keyBy(locatedSegments, 'segmentName');

  const outPath = normalizeOutTemplatePath(
    path.resolve(
      cwd,
      outCwdRelativeDir,
      typeof segmentName === 'string' ? segmentName || ROOT_SEGMENT_FILE_NAME : '',
      relativeDir,
      path.basename(templateFilePath).replace('.ejs', '')
    ),
    packageJson
  );

  let placeholder = `// This is a temporary placeholder to avoid compilation errors if client is imported before it's generated.
// If you still see this text, the client is not generated yet because of an unknown problem.
// Feel free to report an issue at https://github.com/finom/vovk/issues`;
  placeholder = outPath.endsWith('.py') ? placeholder.replace(/\/\//g, '#') : placeholder;

  const getFirstLineBanner = (type: 'html' | 'sh' | 'c' = 'c') => {
    const text = `auto-generated by vovk-cli v${vovkCliPackage.version} at ${new Date().toISOString()}`;
    switch (type) {
      case 'html':
        return `<!-- ${text} -->`;
      case 'sh':
        return `# ${text}`;
      case 'c':
        return `// ${text}`;
    }
  };

  // Data for the EJS templates:
  const t = {
    _, // lodash
    hasMixins,
    isVovkProject,
    package: packageJson,
    readme,
    snippets,
    ROOT_SEGMENT_FILE_NAME,
    apiRoot: origin ? `${origin}/${config.rootEntry}` : apiRoot,
    imports,
    schema: fullSchema,
    VovkSchemaIdEnum,
    createCodeExamples,
    compileJSONSchemaToTypeScriptType,
    YAML,
    TOML,
    getFirstLineBanner,
    nodeNextResolutionExt: {
      ts: isNodeNextResolution ? '.ts' : '',
      js: isNodeNextResolution ? '.js' : '',
      cjs: isNodeNextResolution ? '.cjs' : '',
      mjs: isNodeNextResolution ? '.mjs' : '',
    },
    schemaOutDir:
      typeof segmentName === 'string'
        ? path.relative(path.join(outCwdRelativeDir, segmentName || ROOT_SEGMENT_FILE_NAME), config.schemaOutDir)
        : path.relative(outCwdRelativeDir, config.schemaOutDir),
    segmentMeta: Object.fromEntries(
      Object.values(fullSchema.segments).map(({ segmentName: sName, forceApiRoot }) => {
        const { routeFilePath = null } = locatedSegmentsByName[sName] ?? {};
        const segmentImportPath = routeFilePath
          ? path.relative(
              path.resolve(
                cwd,
                outCwdRelativeDir,
                typeof segmentName === 'string' ? segmentName || ROOT_SEGMENT_FILE_NAME : '.'
              ),
              path.resolve(cwd, routeFilePath)
            )
          : null;
        const segmentConfig = {
          ...config.generatorConfig.segments?.[sName],
          // ...templateDef.generatorConfig?.segments?.[sName],
        };
        const { origin: segmentConfigOrigin, rootEntry: segmentConfigRootEntry, segmentNameOverride } = segmentConfig;

        const reExports = {
          ...segmentConfig.reExports,
          ...(isBundle ? projectInfo.config.bundle.generatorConfig?.reExports : {}),
        };

        return [
          sName,
          {
            forceApiRoot:
              forceApiRoot ??
              (segmentConfigOrigin || segmentConfigRootEntry
                ? `${segmentConfigOrigin ?? origin}/${segmentConfigRootEntry ?? config.rootEntry}`
                : null),
            routeFilePath,
            segmentImportPath,
            segmentNameOverride,
            reExports: _.mapValues(reExports ?? {}, (p) =>
              p.startsWith('.')
                ? path.relative(
                    path.join(
                      outCwdRelativeDir,
                      typeof segmentName === 'string' ? segmentName || ROOT_SEGMENT_FILE_NAME : '.'
                    ),
                    path.resolve(cwd, p)
                  )
                : p
            ),
          },
        ];
      })
    ),
  };

  if (data.imports instanceof Array) {
    for (const imp of data.imports) {
      t.imports = {
        ...t.imports,
        [imp]: await import(imp),
      };
    }
  }

  // Render the template
  let rendered = templateFilePath.endsWith('.ejs')
    ? await ejs.render(
        content,
        { t },
        {
          filename: templateFilePath,
          async: true,
        }
      )
    : templateContent;

  // Optionally prettify
  if (prettifyClient) {
    rendered = await prettify(rendered, outPath);
  }

  if (isEnsuringClient) {
    rendered = rendered + `\n\n${placeholder}`;
  }

  // Read existing file content to compare
  const existingContent = await fs.readFile(outPath, 'utf-8').catch(() => null);

  // Determine if we need to rewrite the file, ignore 1st line
  const needsWriting = isEnsuringClient
    ? !existingContent
    : !existingContent ||
      existingContent.trim().split('\n').slice(1).join('\n') !== rendered.trim().split('\n').slice(1).join('\n');

  if (needsWriting) {
    await fs.mkdir(path.dirname(outPath), { recursive: true });
    await fs.writeFile(outPath, rendered, 'utf-8');
  }

  return { written: needsWriting };
}
