import fs from 'fs/promises';
import path from 'node:path';
import ejs from 'ejs';
import _ from 'lodash';
import type { VovkSchema } from 'vovk';
import {
  createCodeSamples,
  VovkReadmeConfig,
  VovkSchemaIdEnum,
  VovkSamplesConfig,
  type VovkStrictConfig,
} from 'vovk/internal';
import * as YAML from 'yaml';
import TOML from '@iarna/toml';
import type { PackageJson } from 'type-fest';
import { prettify } from '../utils/prettify.mjs';
import type { ProjectInfo } from '../getProjectInfo/index.mjs';
import type { ClientTemplateFile } from './getClientTemplateFiles.mjs';
import { ROOT_SEGMENT_FILE_NAME } from '../dev/writeOneSegmentSchemaFile.mjs';
import type { Segment } from '../utils/locateSegments.mjs';
import { compileJSONSchemaToTypeScriptType } from '../utils/compileJSONSchemaToTypeScriptType.mjs';
import { OpenAPIObject } from 'openapi3-ts/oas31';
import { getTemplateClientImports } from './getTemplateClientImports.mjs';

export function normalizeOutTemplatePath(out: string, packageJson: PackageJson): string {
  return out.replace('[package_name]', packageJson.name?.replace(/-/g, '_') ?? 'my_package_name');
}

export async function writeOneClientFile({
  cwd,
  projectInfo,
  clientTemplateFile,
  fullSchema,
  prettifyClient,
  segmentName,
  // imports,
  templateContent,
  matterResult: { data, content },
  openAPIObject,
  package: packageJson,
  readme,
  samples,
  reExports,
  isEnsuringClient,
  outCwdRelativeDir,
  templateDef,
  locatedSegments,
  isNodeNextResolution,
  hasMixins,
  isVovkProject,
  vovkCliPackage,
  isBundle,
  origin,
  configKey,
  cliSchemaPath,
  projectConfig,
}: {
  cwd: string;
  projectInfo: ProjectInfo;
  clientTemplateFile: ClientTemplateFile;
  fullSchema: VovkSchema;
  prettifyClient: boolean;
  segmentName: string | null; // null for composed client
  // imports: ClientImports;
  templateContent: string;
  matterResult: {
    data: {
      imports?: string[];
    };
    content: string;
  };
  openAPIObject: OpenAPIObject;
  package: PackageJson;
  readme: VovkReadmeConfig;
  samples: VovkSamplesConfig;
  reExports: VovkStrictConfig['outputConfig']['reExports'];
  isEnsuringClient: boolean;
  outCwdRelativeDir: string;
  templateDef: VovkStrictConfig['clientTemplateDefs'][string];
  locatedSegments: Segment[];
  isNodeNextResolution: boolean;
  hasMixins: boolean;
  isVovkProject: boolean;
  vovkCliPackage: PackageJson;
  isBundle: boolean;
  origin: string | null;
  configKey: 'composedClient' | 'segmentedClient';
  cliSchemaPath: string | null;
  projectConfig: VovkStrictConfig;
}) {
  const { config } = projectInfo;

  const { templateFilePath, relativeDir } = clientTemplateFile;
  const locatedSegmentsByName = _.keyBy(locatedSegments, 'segmentName');

  const outPath = normalizeOutTemplatePath(
    path.resolve(
      cwd,
      outCwdRelativeDir,
      typeof segmentName === 'string' ? segmentName || ROOT_SEGMENT_FILE_NAME : '',
      relativeDir,
      path.basename(templateFilePath).replace('.ejs', '')
    ),
    packageJson
  );

  let placeholder = templateFilePath.endsWith('.json.ejs')
    ? ''
    : `// This is a temporary placeholder to avoid compilation errors if client is imported before it's generated.
// If you still see this text, the client is not generated yet because of an unknown problem.
// Feel free to report an issue at https://github.com/finom/vovk/issues`;

  placeholder = outPath.endsWith('.py') ? placeholder.replace(/\/\//g, '#') : placeholder;

  const getFirstLineBanner = (type: 'html' | 'sh' | 'c' = 'c') => {
    const text = `Generated by vovk-cli v${vovkCliPackage.version} at ${new Date().toISOString()}`;
    switch (type) {
      case 'html':
        return `<!-- ${text} -->`;
      case 'sh':
        return `# ${text}`;
      case 'c':
        return `// ${text}`;
    }
  };

  reExports = _.mapValues(reExports ?? {}, (p) =>
    p.startsWith('.')
      ? path.relative(
          path.join(outCwdRelativeDir, typeof segmentName === 'string' ? segmentName || ROOT_SEGMENT_FILE_NAME : '.'),
          path.resolve(cwd, p)
        )
      : p
  );

  // Data for the EJS templates:
  const t = {
    _, // lodash
    hasMixins,
    isVovkProject,
    package: packageJson,
    readme,
    samples,
    reExports,
    openapi: openAPIObject,
    ROOT_SEGMENT_FILE_NAME,
    apiRoot: origin ? `${origin}/${config.rootEntry}` : undefined,
    imports: {},
    schema: fullSchema,
    config: projectConfig,
    VovkSchemaIdEnum,
    createCodeSamples,
    compileJSONSchemaToTypeScriptType,
    YAML,
    TOML,
    getFirstLineBanner,
    nodeNextResolutionExt: {
      ts: isNodeNextResolution ? '.ts' : '',
      js: isNodeNextResolution ? '.js' : '',
      cjs: isNodeNextResolution ? '.cjs' : '',
      mjs: isNodeNextResolution ? '.mjs' : '',
    },
    schemaOutDir:
      typeof segmentName === 'string'
        ? path.relative(
            path.join(outCwdRelativeDir, segmentName || ROOT_SEGMENT_FILE_NAME),
            cliSchemaPath ?? config.schemaOutDir
          )
        : path.relative(outCwdRelativeDir, cliSchemaPath ?? config.schemaOutDir),
    commonImports: getTemplateClientImports({
      config: projectConfig,
      fullSchema,
      isBundle,
      outCwdRelativeDir,
      segmentName,
      outputConfigs: [templateDef.outputConfig ?? {}],
    })['composedClient'],
    segmentImports: Object.fromEntries(
      Object.values(fullSchema.segments).map(({ segmentName: sName }) => {
        const clientImports = getTemplateClientImports({
          config: projectConfig,
          fullSchema,
          segmentName: sName,
          isBundle,
          outCwdRelativeDir,
          outputConfigs: [projectConfig[configKey].outputConfig ?? {}, templateDef.outputConfig ?? {}],
        });
        const imports =
          configKey === 'composedClient' ? clientImports['composedClient'] : clientImports['segmentedClient'][sName];

        return [sName, imports];
      })
    ),
    segmentMeta: Object.fromEntries(
      Object.values(fullSchema.segments).map(({ segmentName: sName, forceApiRoot }) => {
        const { routeFilePath = null } = locatedSegmentsByName[sName] ?? {};
        const segmentImportPath = routeFilePath
          ? path.relative(
              path.resolve(
                cwd,
                outCwdRelativeDir,
                typeof segmentName === 'string' ? segmentName || ROOT_SEGMENT_FILE_NAME : '.'
              ),
              path.resolve(cwd, routeFilePath)
            )
          : null;
        const segmentConfig = {
          ...config.outputConfig.segments?.[sName],
          // ...templateDef.outputConfig?.segments?.[sName],
        };
        const { origin: segmentConfigOrigin, rootEntry: segmentConfigRootEntry, segmentNameOverride } = segmentConfig;

        return [
          sName,
          {
            forceApiRoot:
              forceApiRoot ??
              (segmentConfigOrigin || segmentConfigRootEntry
                ? `${segmentConfigOrigin ?? origin}/${segmentConfigRootEntry ?? config.rootEntry}`
                : null),
            routeFilePath,
            segmentImportPath,
            segmentNameOverride,
          },
        ];
      })
    ),
  };

  if (data.imports instanceof Array) {
    for (const imp of data.imports) {
      t.imports = {
        [imp]: await import(imp),
      };
    }
  }

  // Render the template
  let rendered = templateFilePath.endsWith('.ejs')
    ? await ejs.render(
        content,
        { t },
        {
          filename: templateFilePath,
          async: true,
        }
      )
    : templateContent;

  // Optionally prettify
  if (prettifyClient) {
    rendered = await prettify(rendered, outPath);
  }

  if (isEnsuringClient) {
    rendered = rendered + `\n\n${placeholder}`;
  }

  // Read existing file content to compare
  const existingContent = await fs.readFile(outPath, 'utf-8').catch(() => null);

  // Determine if we need to rewrite the file, ignore 1st line
  const needsWriting = isEnsuringClient
    ? !existingContent
    : !existingContent ||
      existingContent.trim().split('\n').slice(1).join('\n') !== rendered.trim().split('\n').slice(1).join('\n');

  if (needsWriting) {
    await fs.mkdir(path.dirname(outPath), { recursive: true });
    await fs.writeFile(outPath, rendered, 'utf-8');
  }

  return { written: needsWriting };
}
